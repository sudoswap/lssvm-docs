{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"What Is Sudoswap? The sudoswap AMM \u2013 or just sudoswap for short \u2013 is a minimal, gas-efficient automated market maker (AMM) protocol that facilitates NFT-to-token swaps (and vice versa) using customizable bonding curves. sudoswap supports ERC721 and ERC1155 NFTs, as well as all ETH and ERC20 tokens. Liquidity providers (LPs) can deposit assets into single-sided buy or sell pools, or into dual-sided trade pools which buy and sell NFTs with an optional spread to capture trading fees. Similar to other floor NFT protocols, sudoswap makes no distinction between different ERC721 IDs. Pools that are willing to buy or sell NFTs will return the same price no matter which NFT is sent in or out from the collection. How Does Sudoswap Work? Sudoswap is an AMM protocol for NFTs, which means that users buy from or sell into liquidity pools instead of directly trading between themselves. If you're familiar with Uniswap, it's a similar concept but for NFTs. Here's how it works: Liquidity providers deposit NFTs and/or ETH (or an ERC20 token) into liquidity pools. They choose whether they would like to buy or sell NFTs (or both) and specify a starting price and bonding curve parameters. Users can then buy NFTs from or sell NFTs into these pools. Every time an item is bought or sold, the price to buy or sell another item changes for the pool based on its bonding curve. At any time, liquidity providers can change the parameters of their pool or withdraw assets. What Is A Liquidity Pool? A pool, or liquidity pool, is a smart contract that allows you to instantly swap between two assets. On sudoswap, the most common type of pool is an NFT<>ETH pool, which means that anyone holding NFTs from that collection can instantly swap them for ETH, or vice versa. Pools use a bonding curve to determine the relative price at which one asset is traded for another. The more an asset is bought from the pool, the more expensive it becomes. Conversely, the more an asset is sold to the pool, the cheaper it becomes. Ideally, a pool contains some amount of both assets, enabling users to swap back and forth between them. However, it's also possible to create a pool with just one asset, meaning that users will only be able to buy that asset from the pool. Bonding Curves A bonding curve is a mathematical formula which defines the relationship between an asset's price and its supply. Bonding curves are a key feature of automated market makers since they are used to algorithmically adjust asset prices. sudoswap supports three types of bonding curve: linear, exponential, and XYK (constant product). Linear With a linear bonding curve, the price of an NFT is increased by a flat amount (called delta ) every time an item is bought from the pool. Conversely, the price of the NFT is decreased by that same flat amount every time an item is sold to the pool. For example, a liquidity provider may create an NFT<>ETH pool with a Start Price of 1 ETH and a delta of 0.1 ETH. Assuming they provide enough liquidity, the price of an NFT will increase to 1.1 ETH after one item is purchased from the pool. After a second item is purchased, the price will increase to 1.2 ETH, and so on and so forth. At any point, if an NFT is sold to the pool, the price will decrease by 0.1 ETH. Exponential With an exponential bonding curve, the price of an NFT is increased by a certain percentage (also called delta ) every time an item is bought from the pool. Conversely, the price of the NFT is decreased equivalently every time an item is sold to the pool. To calculate the equivalent decrease, convert the percentage to a decimal index (e.g. for 50%, the index would be 1.5) and divide the price by this number. For example, a liquidity provider may create an NFT<>ETH pool with a Start Price of 2 ETH and a delta of 50%. Assuming they provide enough liquidity, the price of an NFT will increase to 2 + 50% = 3 ETH after one item is purchased from the pool. After a second item is purchased, the price will increase to 3 + 50% = 4.5 ETH, and so on and so forth. At any point, if an NFT is sold to the pool, the price will be divided by 1.5. XYK (Constant Product) With an XYK curve, the price of an NFT is adjusted every time an item is bought from or sold to the pool, such that the product of two virtual reserves remains constant after every trade. These virtual reserves correspond to the number and value of NFTs the pool will buy or sell. An additional concentration parameter allows liquidity providers to adjust (i.e. tighten or loosen) XYK curves. For information on how exactly pricing is calculated for XYK curves, refer to the Pricing page in the technical reference.","title":"What Is Sudoswap?"},{"location":"#what-is-sudoswap","text":"The sudoswap AMM \u2013 or just sudoswap for short \u2013 is a minimal, gas-efficient automated market maker (AMM) protocol that facilitates NFT-to-token swaps (and vice versa) using customizable bonding curves. sudoswap supports ERC721 and ERC1155 NFTs, as well as all ETH and ERC20 tokens. Liquidity providers (LPs) can deposit assets into single-sided buy or sell pools, or into dual-sided trade pools which buy and sell NFTs with an optional spread to capture trading fees. Similar to other floor NFT protocols, sudoswap makes no distinction between different ERC721 IDs. Pools that are willing to buy or sell NFTs will return the same price no matter which NFT is sent in or out from the collection.","title":"What Is Sudoswap?"},{"location":"#how-does-sudoswap-work","text":"Sudoswap is an AMM protocol for NFTs, which means that users buy from or sell into liquidity pools instead of directly trading between themselves. If you're familiar with Uniswap, it's a similar concept but for NFTs. Here's how it works: Liquidity providers deposit NFTs and/or ETH (or an ERC20 token) into liquidity pools. They choose whether they would like to buy or sell NFTs (or both) and specify a starting price and bonding curve parameters. Users can then buy NFTs from or sell NFTs into these pools. Every time an item is bought or sold, the price to buy or sell another item changes for the pool based on its bonding curve. At any time, liquidity providers can change the parameters of their pool or withdraw assets.","title":"How Does Sudoswap Work?"},{"location":"#what-is-a-liquidity-pool","text":"A pool, or liquidity pool, is a smart contract that allows you to instantly swap between two assets. On sudoswap, the most common type of pool is an NFT<>ETH pool, which means that anyone holding NFTs from that collection can instantly swap them for ETH, or vice versa. Pools use a bonding curve to determine the relative price at which one asset is traded for another. The more an asset is bought from the pool, the more expensive it becomes. Conversely, the more an asset is sold to the pool, the cheaper it becomes. Ideally, a pool contains some amount of both assets, enabling users to swap back and forth between them. However, it's also possible to create a pool with just one asset, meaning that users will only be able to buy that asset from the pool.","title":"What Is A Liquidity Pool?"},{"location":"#bonding-curves","text":"A bonding curve is a mathematical formula which defines the relationship between an asset's price and its supply. Bonding curves are a key feature of automated market makers since they are used to algorithmically adjust asset prices. sudoswap supports three types of bonding curve: linear, exponential, and XYK (constant product).","title":"Bonding Curves"},{"location":"#linear","text":"With a linear bonding curve, the price of an NFT is increased by a flat amount (called delta ) every time an item is bought from the pool. Conversely, the price of the NFT is decreased by that same flat amount every time an item is sold to the pool. For example, a liquidity provider may create an NFT<>ETH pool with a Start Price of 1 ETH and a delta of 0.1 ETH. Assuming they provide enough liquidity, the price of an NFT will increase to 1.1 ETH after one item is purchased from the pool. After a second item is purchased, the price will increase to 1.2 ETH, and so on and so forth. At any point, if an NFT is sold to the pool, the price will decrease by 0.1 ETH.","title":"Linear"},{"location":"#exponential","text":"With an exponential bonding curve, the price of an NFT is increased by a certain percentage (also called delta ) every time an item is bought from the pool. Conversely, the price of the NFT is decreased equivalently every time an item is sold to the pool. To calculate the equivalent decrease, convert the percentage to a decimal index (e.g. for 50%, the index would be 1.5) and divide the price by this number. For example, a liquidity provider may create an NFT<>ETH pool with a Start Price of 2 ETH and a delta of 50%. Assuming they provide enough liquidity, the price of an NFT will increase to 2 + 50% = 3 ETH after one item is purchased from the pool. After a second item is purchased, the price will increase to 3 + 50% = 4.5 ETH, and so on and so forth. At any point, if an NFT is sold to the pool, the price will be divided by 1.5.","title":"Exponential"},{"location":"#xyk-constant-product","text":"With an XYK curve, the price of an NFT is adjusted every time an item is bought from or sold to the pool, such that the product of two virtual reserves remains constant after every trade. These virtual reserves correspond to the number and value of NFTs the pool will buy or sell. An additional concentration parameter allows liquidity providers to adjust (i.e. tighten or loosen) XYK curves. For information on how exactly pricing is calculated for XYK curves, refer to the Pricing page in the technical reference.","title":"XYK (Constant Product)"},{"location":"managing-collections/faq/","text":"Frequently Asked Questions This page contains some of the most frequently asked questions among NFT collection owners. Why isn't my collection showing in the search bar? For a collection to show up in the search bar, it must have at least one liquidity pool or past volume on sudoswap. If your collection only recently met this requirement, please allow some time for sudoswap to process this.","title":"Frequently Asked Questions (FAQ)"},{"location":"managing-collections/faq/#frequently-asked-questions","text":"This page contains some of the most frequently asked questions among NFT collection owners.","title":"Frequently Asked Questions"},{"location":"managing-collections/faq/#why-isnt-my-collection-showing-in-the-search-bar","text":"For a collection to show up in the search bar, it must have at least one liquidity pool or past volume on sudoswap. If your collection only recently met this requirement, please allow some time for sudoswap to process this.","title":"Why isn't my collection showing in the search bar?"},{"location":"managing-collections/listing/","text":"Listing on Sudoswap Compatible ERC721 and ERC1155 NFTs can be deposited and traded on sudoswap immediately after they are minted, without the need for collections to be manually listed. For a collection to show up in the search bar, it must have at least one liquidity pool or past volume on sudoswap. However, even if a collection does not show up, holders can still create liquidity pools for it as normal. Launching on Sudoswap There is no special procedure to launch an NFT collection on sudoswap. Simply mint your NFTs and deposit them to an auction or other liquidity pool of your choice: Deploy an NFT smart contract as you would for any other collection. Mint part or all of the supply to an address you control. Create an auction or other liquidity pool on sudoswap with those NFTs. Tell collectors to buy from the liquidity pool.","title":"Launching on Sudoswap"},{"location":"managing-collections/listing/#listing-on-sudoswap","text":"Compatible ERC721 and ERC1155 NFTs can be deposited and traded on sudoswap immediately after they are minted, without the need for collections to be manually listed. For a collection to show up in the search bar, it must have at least one liquidity pool or past volume on sudoswap. However, even if a collection does not show up, holders can still create liquidity pools for it as normal.","title":"Listing on Sudoswap"},{"location":"managing-collections/listing/#launching-on-sudoswap","text":"There is no special procedure to launch an NFT collection on sudoswap. Simply mint your NFTs and deposit them to an auction or other liquidity pool of your choice: Deploy an NFT smart contract as you would for any other collection. Mint part or all of the supply to an address you control. Create an auction or other liquidity pool on sudoswap with those NFTs. Tell collectors to buy from the liquidity pool.","title":"Launching on Sudoswap"},{"location":"reference/contracts/","text":"Contract Addresses sudoswap V2 The current version of the sudoswap protocol. Mainnet Factory & Router PAIR_FACTORY_V2: 0xA020d57aB0448Ef74115c112D18a9C231CC86000 VERY_FAST_ROUTER_V2: 0x090C236B62317db226e6ae6CD4c0Fd25b7028b65 Price Curves LINEAR_CURVE_V2: 0xe5d78fec1a7f42d2F3620238C498F088A866FdC5 EXPONENTIAL_CURVE_V2: 0xfa056C602aD0C0C4EE4385b3233f2Cb06730334a XYK_CURVE_V2: 0xc7fB91B6cd3C67E02EC08013CEBb29b1241f3De5 GDA_CURVE_V2: 0x1fD5876d4A3860Eb0159055a3b7Cb79fdFFf6B67 Other SETTINGS_FACTORY_V2: 0xF4F439A6A152cFEcb1F34d726D490F82Bcb3c2C7 PROPERTY_CHECKER_FACTORY_V2: 0x031b216FaBec82310FEa3426b33455609b99AfC1 ROYALTY_ENGINE_V2: 0xBc40d21999b4BF120d330Ee3a2DE415287f626C9 ZERO_EX_ROUTER_V2: 0xe4ac8eDd513074BA5f78DCdDc57680EF68Fa0CaE Goerli Factory & Router PAIR_FACTORY_V2: 0x967544b2Dd5c1c7A459e810C9B60AE4FC8227201 VERY_FAST_ROUTER_V2: 0xb3d6192E9940bBa479C32596431D215fAEE5f723 Price Curves LINEAR_CURVE_V2: 0x9fe1E403c043214017a6719c1b64190c634229eF EXPONENTIAL_CURVE_V2: 0x60C3aeEb3b8fade6dF3DFdC52A4630D492cDD7e7 XYK_CURVE_V2: 0x8F03234E08A0068572d3AfE10c45d4840d3f29e8 GDA_CURVE_V2: 0x5e9a0Ef66A6BC2E6Ac7C9811374521f7BAd89e53 Other ROYALTY_ENGINE_V2: 0x76A0f80417514e7577eBAb30e8C0860759CA1704 sudoswap V1 While V1 smart contracts remain accessible at the addresses below, the sudoswap V1 frontend has been deprecated. Please use sudoswap V2 for new liquidity pools and smart contract integrations. Mainnet EXPONENTIAL_CURVE: 0x432f962D8209781da23fB37b6B59ee15dE7d9841 LINEAR_CURVE: 0x5B6aC51d9B1CeDE0068a1B26533CAce807f883Ee XYK_CURVE: 0x7942E264e21C5e6CbBA45fe50785a15D3BEb1DA0 PAIR_FACTORY: 0xb16c1342E617A5B6E4b631EB114483FDB289c0A4 PAIR_ROUTER: 0x2b2e8cda09bba9660dca5cb6233787738ad68329 Goerli EXPONENTIAL_CURVE: 0x0D807bd5fF2C4eF298755bE30E22926b33244B0c LINEAR_CURVE: 0xaC6dcFF6E13132f075e36cA3a7F403236f869438 XYK_CURVE: 0x02363a2F1B2c2C5815cb6893Aa27861BE0c4F760 PAIR_FACTORY: 0xF0202E9267930aE942F0667dC6d805057328F6dC PAIR_ROUTER: 0x25b4EfC43c9dCAe134233CD577fFca7CfAd6748F","title":"Contract Addresses"},{"location":"reference/contracts/#contract-addresses","text":"","title":"Contract Addresses"},{"location":"reference/contracts/#sudoswap-v2","text":"The current version of the sudoswap protocol.","title":"sudoswap V2"},{"location":"reference/contracts/#mainnet","text":"Factory & Router PAIR_FACTORY_V2: 0xA020d57aB0448Ef74115c112D18a9C231CC86000 VERY_FAST_ROUTER_V2: 0x090C236B62317db226e6ae6CD4c0Fd25b7028b65 Price Curves LINEAR_CURVE_V2: 0xe5d78fec1a7f42d2F3620238C498F088A866FdC5 EXPONENTIAL_CURVE_V2: 0xfa056C602aD0C0C4EE4385b3233f2Cb06730334a XYK_CURVE_V2: 0xc7fB91B6cd3C67E02EC08013CEBb29b1241f3De5 GDA_CURVE_V2: 0x1fD5876d4A3860Eb0159055a3b7Cb79fdFFf6B67 Other SETTINGS_FACTORY_V2: 0xF4F439A6A152cFEcb1F34d726D490F82Bcb3c2C7 PROPERTY_CHECKER_FACTORY_V2: 0x031b216FaBec82310FEa3426b33455609b99AfC1 ROYALTY_ENGINE_V2: 0xBc40d21999b4BF120d330Ee3a2DE415287f626C9 ZERO_EX_ROUTER_V2: 0xe4ac8eDd513074BA5f78DCdDc57680EF68Fa0CaE","title":"Mainnet"},{"location":"reference/contracts/#goerli","text":"Factory & Router PAIR_FACTORY_V2: 0x967544b2Dd5c1c7A459e810C9B60AE4FC8227201 VERY_FAST_ROUTER_V2: 0xb3d6192E9940bBa479C32596431D215fAEE5f723 Price Curves LINEAR_CURVE_V2: 0x9fe1E403c043214017a6719c1b64190c634229eF EXPONENTIAL_CURVE_V2: 0x60C3aeEb3b8fade6dF3DFdC52A4630D492cDD7e7 XYK_CURVE_V2: 0x8F03234E08A0068572d3AfE10c45d4840d3f29e8 GDA_CURVE_V2: 0x5e9a0Ef66A6BC2E6Ac7C9811374521f7BAd89e53 Other ROYALTY_ENGINE_V2: 0x76A0f80417514e7577eBAb30e8C0860759CA1704","title":"Goerli"},{"location":"reference/contracts/#sudoswap-v1","text":"While V1 smart contracts remain accessible at the addresses below, the sudoswap V1 frontend has been deprecated. Please use sudoswap V2 for new liquidity pools and smart contract integrations.","title":"sudoswap V1"},{"location":"reference/contracts/#mainnet_1","text":"EXPONENTIAL_CURVE: 0x432f962D8209781da23fB37b6B59ee15dE7d9841 LINEAR_CURVE: 0x5B6aC51d9B1CeDE0068a1B26533CAce807f883Ee XYK_CURVE: 0x7942E264e21C5e6CbBA45fe50785a15D3BEb1DA0 PAIR_FACTORY: 0xb16c1342E617A5B6E4b631EB114483FDB289c0A4 PAIR_ROUTER: 0x2b2e8cda09bba9660dca5cb6233787738ad68329","title":"Mainnet"},{"location":"reference/contracts/#goerli_1","text":"EXPONENTIAL_CURVE: 0x0D807bd5fF2C4eF298755bE30E22926b33244B0c LINEAR_CURVE: 0xaC6dcFF6E13132f075e36cA3a7F403236f869438 XYK_CURVE: 0x02363a2F1B2c2C5815cb6893Aa27861BE0c4F760 PAIR_FACTORY: 0xF0202E9267930aE942F0667dC6d805057328F6dC PAIR_ROUTER: 0x25b4EfC43c9dCAe134233CD577fFca7CfAd6748F","title":"Goerli"},{"location":"reference/pair-creation/","text":"Creating A Pair New pairs for the sudoswap AMM are created with the LSSVMPairFactory . LPs will call either createPairETH or createPairERC20 depending on their token type (i.e. if they wish to utilize ETH or an ERC20). This will deploy a new LSSVMPair contract. Each pair has one owner (initially set to be the caller), and multiple pools for the same token and NFT pair can exist, even for the same owner. This is due to each pair having its own potentially different spot price and bonding curve. Pair Types Each pair can be one of 3 types: Token, NFT, or Trade. A Token pair holds either ETH or an ERC20 token and will give a quote for how much it will pay for any NFT in the collection it has been created for. An NFT pair holds NFTs and will give a quote for how much it will sell for any NFT it has in its inventory. A Trade pair holds both NFTs and tokens, and it will give a quote for both buying and selling, with a spread between the quotes as the LP fee. Pair Parameters During the creation call, LPs supply the following parameters: IERC721 _nft, // The ERC721 token side of the pair ICurve _bondingCurve, // The bonding curve used to price the pair address payable _assetRecipient, // If set to a non-zero address, assets sent to the pair during a swap will be forwarded to this address. NOTE: unavailable for Trade pairs. LSSVMPair.PoolType _poolType, // The pair's type (Token, NFT, Trade) uint256 _delta, // The bonding curve's parameter (more on this in the Bonding Curve section) uint256 _fee, // The spread between buy and sell quotes. NOTE: only for Trade pairs. uint256 _spotPrice, // The initial sell quote the pair will return if an NFT is sold into it. uint256[] calldata _initialNFTIDs // The list of IDs to transfer from the caller to the pair For an ERC20 pair, two other parameters are also added: ERC20 token // The token to be used for the token side of the pair. uint256 initialTokenBalance // The amount of tokens to send into the pair. (The createPairETH call is payable, and msg.value is used instead) The factory uses a modified minimal proxy pattern to allow deployed pairs to cheaply access certain values the same way that immutable normally works. See LSSVMPairCloner for more technical details. As a result, several of the above parameters cannot be changed after a pool is deployed: _nft, _bondingCurve, _poolType, token // NOTE: only for ERC20 pairs Managing A Pair The owner of a pair can modify certain parameters to change the pair's pricing and inventory. To modify spotPrice , delta , and fee , the owner can call changeSpotPrice , changeDelta , and changeFee (only for Trade pairs). To withdraw any NFTs or tokens sent to the pair, the owner can call withdrawERC721 , withdrawERC20 , and withdrawETH (only for ETH pairs).","title":"Pair Creation"},{"location":"reference/pair-creation/#creating-a-pair","text":"New pairs for the sudoswap AMM are created with the LSSVMPairFactory . LPs will call either createPairETH or createPairERC20 depending on their token type (i.e. if they wish to utilize ETH or an ERC20). This will deploy a new LSSVMPair contract. Each pair has one owner (initially set to be the caller), and multiple pools for the same token and NFT pair can exist, even for the same owner. This is due to each pair having its own potentially different spot price and bonding curve.","title":"Creating A Pair"},{"location":"reference/pair-creation/#pair-types","text":"Each pair can be one of 3 types: Token, NFT, or Trade. A Token pair holds either ETH or an ERC20 token and will give a quote for how much it will pay for any NFT in the collection it has been created for. An NFT pair holds NFTs and will give a quote for how much it will sell for any NFT it has in its inventory. A Trade pair holds both NFTs and tokens, and it will give a quote for both buying and selling, with a spread between the quotes as the LP fee.","title":"Pair Types"},{"location":"reference/pair-creation/#pair-parameters","text":"During the creation call, LPs supply the following parameters: IERC721 _nft, // The ERC721 token side of the pair ICurve _bondingCurve, // The bonding curve used to price the pair address payable _assetRecipient, // If set to a non-zero address, assets sent to the pair during a swap will be forwarded to this address. NOTE: unavailable for Trade pairs. LSSVMPair.PoolType _poolType, // The pair's type (Token, NFT, Trade) uint256 _delta, // The bonding curve's parameter (more on this in the Bonding Curve section) uint256 _fee, // The spread between buy and sell quotes. NOTE: only for Trade pairs. uint256 _spotPrice, // The initial sell quote the pair will return if an NFT is sold into it. uint256[] calldata _initialNFTIDs // The list of IDs to transfer from the caller to the pair For an ERC20 pair, two other parameters are also added: ERC20 token // The token to be used for the token side of the pair. uint256 initialTokenBalance // The amount of tokens to send into the pair. (The createPairETH call is payable, and msg.value is used instead) The factory uses a modified minimal proxy pattern to allow deployed pairs to cheaply access certain values the same way that immutable normally works. See LSSVMPairCloner for more technical details. As a result, several of the above parameters cannot be changed after a pool is deployed: _nft, _bondingCurve, _poolType, token // NOTE: only for ERC20 pairs","title":"Pair Parameters"},{"location":"reference/pair-creation/#managing-a-pair","text":"The owner of a pair can modify certain parameters to change the pair's pricing and inventory. To modify spotPrice , delta , and fee , the owner can call changeSpotPrice , changeDelta , and changeFee (only for Trade pairs). To withdraw any NFTs or tokens sent to the pair, the owner can call withdrawERC721 , withdrawERC20 , and withdrawETH (only for ETH pairs).","title":"Managing A Pair"},{"location":"reference/pricing/","text":"Bonding Curves and Pricing sudoswap pairs use bonding curves to determine buy and sell prices. When creating a pair, liquidity providers choose from a list of whitelisted curves. A pair's bonding curve can be read using bondingCurve() and cannot be changed once the pair is created. sudoswap V2 currently has four whitelisted bonding curves: LINEAR_CURVE_V2: 0xe5d78fec1a7f42d2F3620238C498F088A866FdC5 EXPONENTIAL_CURVE_V2: 0xfa056C602aD0C0C4EE4385b3233f2Cb06730334a XYK_CURVE_V2: 0xc7fB91B6cd3C67E02EC08013CEBb29b1241f3De5 GDA_CURVE_V2: 0x1fD5876d4A3860Eb0159055a3b7Cb79fdFFf6B67 How Bonding Curves Work Bonding curves use pair state to determine the appropriate buy or sell price for a given number of NFTs. Specifically, they use a pair's spotPrice and delta to calculate net pricing (exclusive of fees) for numItems NFTs. Curves also calculate the sudoswap protocol fee and, for TRADE pools, the LP's chosen fee/spread. The relevant methods for this, getBuyInfo and getSellInfo , are defined in the ICurve interface . Besides the name, the interface for both methods is identical: function getBuyInfo( uint128 spotPrice, uint128 delta, uint256 numItems, uint256 feeMultiplier, uint256 protocolFeeMultiplier ) external view returns ( CurveErrorCodes.Error error, uint128 newSpotPrice, uint128 newDelta, uint256 inputValue, uint256 tradeFee, uint256 protocolFee ); In addition to returning the net inputValue for a transaction and the relevant tradeFee and protocolFee , these bonding curve methods also return a newSpotPrice and newDelta which are used to adjust the pair's pricing. Note that bonding curves are intended to be pure: they do not modify pair state directly. Instead, pairs update their state themselves based on these return values. Interpreting spotPrice and delta In the original sudoswap bonding curves \u2013 the linear and exponential curves \u2013 spotPrice is the instantaneous price received when selling 1 NFT to the pair. For these curves, the instantaneous price paid when buying 1 NFT from the pair is the spotPrice adjusted upwards by 1 unit of delta (additively or multiplicatively). However, non-standard bonding curves like the XYK and GDA curves use pair state in different ways to enable unique pricing mechanisms. For these curves, spotPrice does not represent the price received when selling an NFT to the pair, and delta does not represent an additive or multiplcative modifier. As a result, users should use the getBuyNFTQuote and getSellNFTQuote methods on pairs themselves to get accurate pricing info. Pricing For Multi-Swaps If a user buys or sells multiple NFTs in one transaction, the price for each NFT will be updated according to the bonding curve. For linear and exponential curves, this means the the spotPrice will update by delta (additively or multiplicatively) for each NFT bought or sold. For example, consider a pair with the linear bonding curve, with a spotPrice of 1 ETH and a delta of 0.1 ETH. If a user sells 5 NFTs to this pair, they will receive: 1 ETH for the first NFT 0.9 ETH for the second NFT 0.8 ETH for the third NFT 0.7 ETH for the fourth NFT 0.6 ETH for the fifth NFT At the end of the multi-swap, the new spotPrice will be set to 0.5 ETH. For non-standard bonding curves, calculating the price of multi-swaps may be more complex; nevertheless, the price of each subsequent NFT is also adjusted according to the curve logic. Overview of Bonding Curves Here is an overview of how pair state is used to calculate pricing for each of the whitelisted bonding curves: Linear Curve The linear curve uses spotPrice to store the price received when selling an NFT to the pair. Following each transaction, the curve performs an additive operation of magnitude delta to update the price. For example, if a user buys an NFT from the pair, the spotPrice will be incremented by delta , and vice-versa. delta is assumed to be set properly by the LP to be the same precision of the pair's underlying token. Exponential Curve The exponential curve also uses spotPrice to store the price received when selling an NFT to the pair. Following each transaction, the curve performs a multiplicative operation of magnitude delta to update the price. For example, if a user buys an NFT from the pair, the spotPrice will be multiplied by delta , and vice-versa. delta is a multiplier assuming a fixed point system where 1e18 is 1. For example, if delta is 1e18 + 1e17 , this represents a 10% change in price each time. XYK Curve The XYK curve uses spotPrice and delta in a non-standard way: to store two virtual reserves. Following each transaction, price adjusts such that the product (multiplication) of the virtual reserves remains constant after every trade. At pool creation, the reserves are set as follows: nftBalance (stored as delta ): the number of NFTs being bought or sold (in the case of trade pools, whichever is greater) plus one tokenBalance (stored as spotPrice ): the number of NFTs being bought or sold (or whichever is greater) multiplied by the start price The net price exclusive of fees for a user to buy x NFTs is inputValueWithoutFee = (x * tokenBalance) / (nftBalance - x) . Conversely, the net price for a user to sell x NFTs is outputValueWithoutFee = (x * tokenBalance) / (nftBalance + x) . Immediately after every trade, the pair state is updated: Pair sells: delta = delta - x and spotPrice = spotPrice + outputValueWithoutFee Pair buys: delta = delta + x and spotPrice = spotPrice - outputValueWithoutFee GDA Curve The GDA curve also uses spotPrice and delta in a non-standard way. It is an implementation of the discrete gradual Dutch auction , where spotPrice is the price of the currently \"auctioned\" NFT irrespective of time decay, and delta stores the auction parameters alpha and lamba , as well as the timestamp of the last trade prevTime . In contrast to the specification linked above, the GDA curve calculates the price of each item as a function of the last. The net price exclusive of fees for a user to buy x NFTs is inputValue_ = (spotPrice * (alpha^x - 1)) / ((alpha - 1) * 2^(lambda * timeElapsed)) where timeElapsed is the time elapsed since the last NFT was sold. Conversely, the net price for a user to sell x NFTs is outputValue_ = (spotPrice * 2^(lambda * timeElapsed) * (alpha^x - 1)) / (alpha^(x - 1) * (alpha - 1)) where timeElapsed is the time elapsed since the last NFT was sold. Immediately after every trade, the pair state is updated: Pair sells: spotPrice = (spotPrice * alpha^x) / 2^(lambda * timeElapsed) Pair buys: spotPrice = (spotPrice * 2^(lambda * timeElapsed)) / alpha^x In both cases, delta is also updated to reflect the current block.timestamp . Parsing delta The GDA curve stores three values in delta . They are the auction parameters alpha and lamba , as well as the timestamp of the last trade prevTime . Since delta is of type uint128 , this is achieved as follows: The highest 40 bits represent alpha with 9 decimals of precision. The middle 40 bits represent lambda with 9 decimals of precision. The lowest 48 bits represent the timestamp of the last trade prevTime . For a given auction, alpha and lambda are constants, while prevTime (and thus delta as a whole) must be updated immediately after every trade.","title":"Bonding Curves and Pricing"},{"location":"reference/pricing/#bonding-curves-and-pricing","text":"sudoswap pairs use bonding curves to determine buy and sell prices. When creating a pair, liquidity providers choose from a list of whitelisted curves. A pair's bonding curve can be read using bondingCurve() and cannot be changed once the pair is created. sudoswap V2 currently has four whitelisted bonding curves: LINEAR_CURVE_V2: 0xe5d78fec1a7f42d2F3620238C498F088A866FdC5 EXPONENTIAL_CURVE_V2: 0xfa056C602aD0C0C4EE4385b3233f2Cb06730334a XYK_CURVE_V2: 0xc7fB91B6cd3C67E02EC08013CEBb29b1241f3De5 GDA_CURVE_V2: 0x1fD5876d4A3860Eb0159055a3b7Cb79fdFFf6B67","title":"Bonding Curves and Pricing"},{"location":"reference/pricing/#how-bonding-curves-work","text":"Bonding curves use pair state to determine the appropriate buy or sell price for a given number of NFTs. Specifically, they use a pair's spotPrice and delta to calculate net pricing (exclusive of fees) for numItems NFTs. Curves also calculate the sudoswap protocol fee and, for TRADE pools, the LP's chosen fee/spread. The relevant methods for this, getBuyInfo and getSellInfo , are defined in the ICurve interface . Besides the name, the interface for both methods is identical: function getBuyInfo( uint128 spotPrice, uint128 delta, uint256 numItems, uint256 feeMultiplier, uint256 protocolFeeMultiplier ) external view returns ( CurveErrorCodes.Error error, uint128 newSpotPrice, uint128 newDelta, uint256 inputValue, uint256 tradeFee, uint256 protocolFee ); In addition to returning the net inputValue for a transaction and the relevant tradeFee and protocolFee , these bonding curve methods also return a newSpotPrice and newDelta which are used to adjust the pair's pricing. Note that bonding curves are intended to be pure: they do not modify pair state directly. Instead, pairs update their state themselves based on these return values.","title":"How Bonding Curves Work"},{"location":"reference/pricing/#interpreting-spotprice-and-delta","text":"In the original sudoswap bonding curves \u2013 the linear and exponential curves \u2013 spotPrice is the instantaneous price received when selling 1 NFT to the pair. For these curves, the instantaneous price paid when buying 1 NFT from the pair is the spotPrice adjusted upwards by 1 unit of delta (additively or multiplicatively). However, non-standard bonding curves like the XYK and GDA curves use pair state in different ways to enable unique pricing mechanisms. For these curves, spotPrice does not represent the price received when selling an NFT to the pair, and delta does not represent an additive or multiplcative modifier. As a result, users should use the getBuyNFTQuote and getSellNFTQuote methods on pairs themselves to get accurate pricing info.","title":"Interpreting spotPrice and delta"},{"location":"reference/pricing/#pricing-for-multi-swaps","text":"If a user buys or sells multiple NFTs in one transaction, the price for each NFT will be updated according to the bonding curve. For linear and exponential curves, this means the the spotPrice will update by delta (additively or multiplicatively) for each NFT bought or sold. For example, consider a pair with the linear bonding curve, with a spotPrice of 1 ETH and a delta of 0.1 ETH. If a user sells 5 NFTs to this pair, they will receive: 1 ETH for the first NFT 0.9 ETH for the second NFT 0.8 ETH for the third NFT 0.7 ETH for the fourth NFT 0.6 ETH for the fifth NFT At the end of the multi-swap, the new spotPrice will be set to 0.5 ETH. For non-standard bonding curves, calculating the price of multi-swaps may be more complex; nevertheless, the price of each subsequent NFT is also adjusted according to the curve logic.","title":"Pricing For Multi-Swaps"},{"location":"reference/pricing/#overview-of-bonding-curves","text":"Here is an overview of how pair state is used to calculate pricing for each of the whitelisted bonding curves:","title":"Overview of Bonding Curves"},{"location":"reference/pricing/#linear-curve","text":"The linear curve uses spotPrice to store the price received when selling an NFT to the pair. Following each transaction, the curve performs an additive operation of magnitude delta to update the price. For example, if a user buys an NFT from the pair, the spotPrice will be incremented by delta , and vice-versa. delta is assumed to be set properly by the LP to be the same precision of the pair's underlying token.","title":"Linear Curve"},{"location":"reference/pricing/#exponential-curve","text":"The exponential curve also uses spotPrice to store the price received when selling an NFT to the pair. Following each transaction, the curve performs a multiplicative operation of magnitude delta to update the price. For example, if a user buys an NFT from the pair, the spotPrice will be multiplied by delta , and vice-versa. delta is a multiplier assuming a fixed point system where 1e18 is 1. For example, if delta is 1e18 + 1e17 , this represents a 10% change in price each time.","title":"Exponential Curve"},{"location":"reference/pricing/#xyk-curve","text":"The XYK curve uses spotPrice and delta in a non-standard way: to store two virtual reserves. Following each transaction, price adjusts such that the product (multiplication) of the virtual reserves remains constant after every trade. At pool creation, the reserves are set as follows: nftBalance (stored as delta ): the number of NFTs being bought or sold (in the case of trade pools, whichever is greater) plus one tokenBalance (stored as spotPrice ): the number of NFTs being bought or sold (or whichever is greater) multiplied by the start price The net price exclusive of fees for a user to buy x NFTs is inputValueWithoutFee = (x * tokenBalance) / (nftBalance - x) . Conversely, the net price for a user to sell x NFTs is outputValueWithoutFee = (x * tokenBalance) / (nftBalance + x) . Immediately after every trade, the pair state is updated: Pair sells: delta = delta - x and spotPrice = spotPrice + outputValueWithoutFee Pair buys: delta = delta + x and spotPrice = spotPrice - outputValueWithoutFee","title":"XYK Curve"},{"location":"reference/pricing/#gda-curve","text":"The GDA curve also uses spotPrice and delta in a non-standard way. It is an implementation of the discrete gradual Dutch auction , where spotPrice is the price of the currently \"auctioned\" NFT irrespective of time decay, and delta stores the auction parameters alpha and lamba , as well as the timestamp of the last trade prevTime . In contrast to the specification linked above, the GDA curve calculates the price of each item as a function of the last. The net price exclusive of fees for a user to buy x NFTs is inputValue_ = (spotPrice * (alpha^x - 1)) / ((alpha - 1) * 2^(lambda * timeElapsed)) where timeElapsed is the time elapsed since the last NFT was sold. Conversely, the net price for a user to sell x NFTs is outputValue_ = (spotPrice * 2^(lambda * timeElapsed) * (alpha^x - 1)) / (alpha^(x - 1) * (alpha - 1)) where timeElapsed is the time elapsed since the last NFT was sold. Immediately after every trade, the pair state is updated: Pair sells: spotPrice = (spotPrice * alpha^x) / 2^(lambda * timeElapsed) Pair buys: spotPrice = (spotPrice * 2^(lambda * timeElapsed)) / alpha^x In both cases, delta is also updated to reflect the current block.timestamp .","title":"GDA Curve"},{"location":"reference/pricing/#parsing-delta","text":"The GDA curve stores three values in delta . They are the auction parameters alpha and lamba , as well as the timestamp of the last trade prevTime . Since delta is of type uint128 , this is achieved as follows: The highest 40 bits represent alpha with 9 decimals of precision. The middle 40 bits represent lambda with 9 decimals of precision. The lowest 48 bits represent the timestamp of the last trade prevTime . For a given auction, alpha and lambda are constants, while prevTime (and thus delta as a whole) must be updated immediately after every trade.","title":"Parsing delta"},{"location":"reference/property-checkers/","text":"Deploying Property Checkers The default Property Checkers introduced in sudoswap V2 can be cloned using the Property Checker Factory at 0x031b216FaBec82310FEa3426b33455609b99AfC1 . The contract has two write methods, one for deploying each type of Property Checker. Both types of default Property Checker conform to the IPropertyChecker.sol interface expected by pair contracts: interface IPropertyChecker { function hasProperties(uint256[] calldata ids, bytes calldata params) external returns(bool); } RangePropertyChecker A RangePropertyChecker can be deployed using the createRangePropertyChecker method. The method's two parameters startInclusive and endInclusive are tokenIds for which all tokenIds in [ startInclusive , endInclusive ] will be considered valid by the Property Checker. When interacting with a RangePropertyChecker , the optional bytes calldata parameter on the hasProperties method is not used. MerklePropertyChecker A MerklePropertyChecker can be deployed using the createMerklePropertyChecker method. The method's one parameter is the root of the Merkle tree of all tokenIds which should be considered valid by the Property Checker. When interacting with a MerklePropertyChecker , the bytes calldata parameter on the hasProperties method is used to pass an array of Merkle proofs for the tokenIds being verified. Individual proofs should be of type bytes32[] and should be encoded together as a single bytes[] . When interacting with a pair that implements a MerklePropertyChecker , traders must have access to Merkle proofs for relevant tokenIds through a frontend interface or otherwise. Merkle Tree Construction MerklePropertyChecker implements OpenZeppelin's MerkleProof.sol contract to verify proofs. The hashing function used for both leaf and branch nodes is keccak256(abi.encodePacked()) . To generate a compatible Merkle tree, you can use a JavaScript library like @openzeppelin/merkle-tree . For this specific library, you must adjust the hashing function in standard.ts to match what is provided above. function standardLeafHash<T extends any[]>(value: T, types: string[]): Bytes { return keccak256(hexToBytes(defaultAbiCoder.encode(types, value))); } Security Note OpenZeppelin advises against constructing Merkle trees with simple hashing functions like keccak256(abi.encodePacked()) due to the risk of second pre-image attacks . However, MerklePropertyChecker is resistant to this type of attack because it is not possible to pass two concatenated keccak256 hashes (totalling 64 bytes in length) as a uint256 tokenId. Not to mention, most NFT contracts do not allow minting of specific tokenIds.","title":"Cloning Property Checkers"},{"location":"reference/property-checkers/#deploying-property-checkers","text":"The default Property Checkers introduced in sudoswap V2 can be cloned using the Property Checker Factory at 0x031b216FaBec82310FEa3426b33455609b99AfC1 . The contract has two write methods, one for deploying each type of Property Checker. Both types of default Property Checker conform to the IPropertyChecker.sol interface expected by pair contracts: interface IPropertyChecker { function hasProperties(uint256[] calldata ids, bytes calldata params) external returns(bool); }","title":"Deploying Property Checkers"},{"location":"reference/property-checkers/#rangepropertychecker","text":"A RangePropertyChecker can be deployed using the createRangePropertyChecker method. The method's two parameters startInclusive and endInclusive are tokenIds for which all tokenIds in [ startInclusive , endInclusive ] will be considered valid by the Property Checker. When interacting with a RangePropertyChecker , the optional bytes calldata parameter on the hasProperties method is not used.","title":"RangePropertyChecker"},{"location":"reference/property-checkers/#merklepropertychecker","text":"A MerklePropertyChecker can be deployed using the createMerklePropertyChecker method. The method's one parameter is the root of the Merkle tree of all tokenIds which should be considered valid by the Property Checker. When interacting with a MerklePropertyChecker , the bytes calldata parameter on the hasProperties method is used to pass an array of Merkle proofs for the tokenIds being verified. Individual proofs should be of type bytes32[] and should be encoded together as a single bytes[] . When interacting with a pair that implements a MerklePropertyChecker , traders must have access to Merkle proofs for relevant tokenIds through a frontend interface or otherwise.","title":"MerklePropertyChecker"},{"location":"reference/property-checkers/#merkle-tree-construction","text":"MerklePropertyChecker implements OpenZeppelin's MerkleProof.sol contract to verify proofs. The hashing function used for both leaf and branch nodes is keccak256(abi.encodePacked()) . To generate a compatible Merkle tree, you can use a JavaScript library like @openzeppelin/merkle-tree . For this specific library, you must adjust the hashing function in standard.ts to match what is provided above. function standardLeafHash<T extends any[]>(value: T, types: string[]): Bytes { return keccak256(hexToBytes(defaultAbiCoder.encode(types, value))); }","title":"Merkle Tree Construction"},{"location":"reference/property-checkers/#security-note","text":"OpenZeppelin advises against constructing Merkle trees with simple hashing functions like keccak256(abi.encodePacked()) due to the risk of second pre-image attacks . However, MerklePropertyChecker is resistant to this type of attack because it is not possible to pass two concatenated keccak256 hashes (totalling 64 bytes in length) as a uint256 tokenId. Not to mention, most NFT contracts do not allow minting of specific tokenIds.","title":"Security Note"},{"location":"reference/swapping/","text":"Swapping Across Pairs The recommended way to make swaps across various pairs is to use the LSSVMRouter . Users can set allowances for tokens and NFTs once for the router, instead of for each new pool they wish to swap with. On the protocol level, the sudoswap AMM does not perform any routing optimization on-chain. Users are expected to know their desired swap paths when calling the router, e.g. via the use of an off-chain indexing service. NFT<>Token Swaps When swapping tokens for NFTs, users can either specify which NFT IDs they want from each pair, or they can ask for any ID from the pair. When swapping from NFT to tokens or from tokens to NFTs, the LSSVMRouter has two types of swaps: a Normal Swap and a Robust Swap. Normal Swap A Normal Swap is conceptually similar to token-to-token swaps on other DEXs. The user sends the router a maximum input amount or minimum output amount (i.e. allowed slippage), as well as a swap route and a deadline. The router will then swap across the various pairs specified. At the end of all the swaps, the router will total all tokens to be received or sent, and revert if the total is beyond the user's specified slippage. Robust Swap In contrast, a Robust Swap does a slippage check per swap pair rather than an aggregate check at the end. If the price for a specified swap pair is past the allowable slippage, the router will silently skip that route and move on to the next one, with no reverts or errors. This is intended for situations where the price can move quickly between your transaction submission and execution. Normal vs Robust Swap To see the difference between these swap types, consider this example: say there are 2 pairs for NFT and ETH. The first pair has a spot price of 1 ETH and a linear curve with a delta of 0.1 ETH. The second pair has a spot price of 1 ETH and a linear curve with a delta of 1 ETH. A user wishes to purchase NFTs, one from each pool for 1 ETH each, with 10% slippage. The user submits a swap transaction. Before this transaction is executed, someone else goes and buys 1 NFT from each pool for 1 ETH each. The new spot price for the first pair is 1.1 ETH, and for the second pair is 2 ETH. If the user had submitted a Normal Swap, they would have sent 2.2 ETH (2 ETH + 0.2 ETH to cover the additional 10% slippage), and the transaction would fail, as they would have sent enough ETH to cover the first swap at the new price of 1.1 ETH, but not enough to cover the second swap at 2 ETH. In contrast, if the user had submitted a Robust Swap, they would have also sent 2.2 ETH, but with a per-swap max cost of 1.1 ETH. The router would have enough to cover the first swap at 1.1 ETH. Then, upon seeing the second swap would cost 2 ETH, the router would skip this pair entirely. The transaction would succeed, refunding 1.1 ETH back to the user, as well as sending them the one NFT they purchased for 1.1 ETH. Thus, the Robust Swap is generally recommended for a better user experience in higher volatility environments, at the cost of slightly more gas. NFT<>NFT Swaps As another added convenience, the LSSVMRouter also supports swapping NFTs for tokens, and then tokens to other NFTs in one transaction. Like the token to NFT swap, users can either specify specific NFT IDs from a pair, or ask for any NFT ID.","title":"Swapping Across Pairs"},{"location":"reference/swapping/#swapping-across-pairs","text":"The recommended way to make swaps across various pairs is to use the LSSVMRouter . Users can set allowances for tokens and NFTs once for the router, instead of for each new pool they wish to swap with. On the protocol level, the sudoswap AMM does not perform any routing optimization on-chain. Users are expected to know their desired swap paths when calling the router, e.g. via the use of an off-chain indexing service.","title":"Swapping Across Pairs"},{"location":"reference/swapping/#nfttoken-swaps","text":"When swapping tokens for NFTs, users can either specify which NFT IDs they want from each pair, or they can ask for any ID from the pair. When swapping from NFT to tokens or from tokens to NFTs, the LSSVMRouter has two types of swaps: a Normal Swap and a Robust Swap.","title":"NFT&lt;&gt;Token Swaps"},{"location":"reference/swapping/#normal-swap","text":"A Normal Swap is conceptually similar to token-to-token swaps on other DEXs. The user sends the router a maximum input amount or minimum output amount (i.e. allowed slippage), as well as a swap route and a deadline. The router will then swap across the various pairs specified. At the end of all the swaps, the router will total all tokens to be received or sent, and revert if the total is beyond the user's specified slippage.","title":"Normal Swap"},{"location":"reference/swapping/#robust-swap","text":"In contrast, a Robust Swap does a slippage check per swap pair rather than an aggregate check at the end. If the price for a specified swap pair is past the allowable slippage, the router will silently skip that route and move on to the next one, with no reverts or errors. This is intended for situations where the price can move quickly between your transaction submission and execution.","title":"Robust Swap"},{"location":"reference/swapping/#normal-vs-robust-swap","text":"To see the difference between these swap types, consider this example: say there are 2 pairs for NFT and ETH. The first pair has a spot price of 1 ETH and a linear curve with a delta of 0.1 ETH. The second pair has a spot price of 1 ETH and a linear curve with a delta of 1 ETH. A user wishes to purchase NFTs, one from each pool for 1 ETH each, with 10% slippage. The user submits a swap transaction. Before this transaction is executed, someone else goes and buys 1 NFT from each pool for 1 ETH each. The new spot price for the first pair is 1.1 ETH, and for the second pair is 2 ETH. If the user had submitted a Normal Swap, they would have sent 2.2 ETH (2 ETH + 0.2 ETH to cover the additional 10% slippage), and the transaction would fail, as they would have sent enough ETH to cover the first swap at the new price of 1.1 ETH, but not enough to cover the second swap at 2 ETH. In contrast, if the user had submitted a Robust Swap, they would have also sent 2.2 ETH, but with a per-swap max cost of 1.1 ETH. The router would have enough to cover the first swap at 1.1 ETH. Then, upon seeing the second swap would cost 2 ETH, the router would skip this pair entirely. The transaction would succeed, refunding 1.1 ETH back to the user, as well as sending them the one NFT they purchased for 1.1 ETH. Thus, the Robust Swap is generally recommended for a better user experience in higher volatility environments, at the cost of slightly more gas.","title":"Normal vs Robust Swap"},{"location":"reference/swapping/#nftnft-swaps","text":"As another added convenience, the LSSVMRouter also supports swapping NFTs for tokens, and then tokens to other NFTs in one transaction. Like the token to NFT swap, users can either specify specific NFT IDs from a pair, or ask for any NFT ID.","title":"NFT&lt;&gt;NFT Swaps"},{"location":"reference/wrapped-pools/","text":"Wrapped Pools sudoswap pools can be wrapped as ERC721 NFTs using the wrapper contract deployed at 0x3767341a7519178f30281fc7D07538EDb55c05a4 . This allows pools to be utilized within any NFT-compatible protocol, for purposes such as lending or fractionalization. At this time, the wrapper contract only supports ERC721<>ETH pools. Overview To wrap a pool, the owner transfers the pool to the wrapper contract using the transferOwnership method on the pool contract: LSSVMPair.transferOwnership(0x3767341a7519178f30281fc7D07538EDb55c05a4,) Then, using the onOwnershipTransferred callback, the wrapper contract mints an ERC721 NFT representing ownership of the wrapped pool to its original owner. The tokenId of the NFT is the contract address of the underlying pool casted to an unsigned integer: tokenId = uint256(uint160(pairAddress)) The holder of a wrapper NFT has full and exclusive control over the underlying pool. Via the wrapper contract, they can: change pool settings such as pricing using the multicall proxy method, unwrap the pool using the reclaimPairs method, which transfers them ownership of the pool and subsequently burns the NFT. Example WrappedSudoPool wrapper = WrappedSudoPool(0x3767341a7519178f30281fc7D07538EDb55c05a4); wrapper.reclaimPairs([LSSVMPair1,...]); Integrating Wrapped Pools Since wrapper NFTs conform to ERC721, they are natively compatible with most NFT protocols. To get information about an underlying pool, start by casting the NFT's tokenId back into the pool's address: pairAddress = address(uint160(tokenId)) Then, read the views inherited from LSSVMPair.sol on that address to determine the pool's parameters: pairVariant() (only ETH pools are supported by the wrapper) bondingCurve() (linear, exponential, etc) nft() (contract address) poolType() (BUY, SELL, or TRADE) and more. You can read a pool's ETH balance using the balance property. To determine the pool's NFT balance, call balanceOf() on the NFT contract itself. Example import { ILSSVMPair } from \"./ILSSVMPair.sol\"; contract Example { function _handleNFT(address _tokenContract, uint256 _tokenId) internal { // Check if NFT is a wrapped sudoswap pool if (_tokenContract == 0x3767341a7519178f30281fc7D07538EDb55c05a4) { // Get underlying pool ILSSVMPair underlyingPair = ILSSVMPair(address(uint160(_tokenId))); // Get information about pool address nft = underlyingPair.nft(); // Underlying NFT contract ILSSVMPair.PoolType type = underlyingPair.poolType(); // BUY, SELL, or TRADE address curve = underlyingPair.bondingCurve(); // Address of bonding curve uint256 balance = underlyingPair.balance; // ETH balance of pool // Do desired logic ... } else {...} } } Valuing Wrapped Pools Valuing wrapped pools can be complex due to diverse pricing curves and the risk of manipulation. To mitigate this, we recommend protocols start by only integrating certain categories of sudoswap pools. For example, for a buy- or sell-only pool using a linear or exponential pricing curve, the total value of the pool can be estimated by multiplying its NFT balance by the NFT's floor price (as provided by an NFT valuation oracle of choice) and adding its ETH balance. Additionally, you should check the pool's pricing at the time of valuation is equal to the NFT's floor price or better. For a linear or exponential pricing curve, this means: Buy-only pools: spotPrice \u2264 floor Sell-only pools: spoPrice \u2265 floor","title":"Wrapped Pools"},{"location":"reference/wrapped-pools/#wrapped-pools","text":"sudoswap pools can be wrapped as ERC721 NFTs using the wrapper contract deployed at 0x3767341a7519178f30281fc7D07538EDb55c05a4 . This allows pools to be utilized within any NFT-compatible protocol, for purposes such as lending or fractionalization. At this time, the wrapper contract only supports ERC721<>ETH pools.","title":"Wrapped Pools"},{"location":"reference/wrapped-pools/#overview","text":"To wrap a pool, the owner transfers the pool to the wrapper contract using the transferOwnership method on the pool contract: LSSVMPair.transferOwnership(0x3767341a7519178f30281fc7D07538EDb55c05a4,) Then, using the onOwnershipTransferred callback, the wrapper contract mints an ERC721 NFT representing ownership of the wrapped pool to its original owner. The tokenId of the NFT is the contract address of the underlying pool casted to an unsigned integer: tokenId = uint256(uint160(pairAddress)) The holder of a wrapper NFT has full and exclusive control over the underlying pool. Via the wrapper contract, they can: change pool settings such as pricing using the multicall proxy method, unwrap the pool using the reclaimPairs method, which transfers them ownership of the pool and subsequently burns the NFT.","title":"Overview"},{"location":"reference/wrapped-pools/#example","text":"WrappedSudoPool wrapper = WrappedSudoPool(0x3767341a7519178f30281fc7D07538EDb55c05a4); wrapper.reclaimPairs([LSSVMPair1,...]);","title":"Example"},{"location":"reference/wrapped-pools/#integrating-wrapped-pools","text":"Since wrapper NFTs conform to ERC721, they are natively compatible with most NFT protocols. To get information about an underlying pool, start by casting the NFT's tokenId back into the pool's address: pairAddress = address(uint160(tokenId)) Then, read the views inherited from LSSVMPair.sol on that address to determine the pool's parameters: pairVariant() (only ETH pools are supported by the wrapper) bondingCurve() (linear, exponential, etc) nft() (contract address) poolType() (BUY, SELL, or TRADE) and more. You can read a pool's ETH balance using the balance property. To determine the pool's NFT balance, call balanceOf() on the NFT contract itself.","title":"Integrating Wrapped Pools"},{"location":"reference/wrapped-pools/#example_1","text":"import { ILSSVMPair } from \"./ILSSVMPair.sol\"; contract Example { function _handleNFT(address _tokenContract, uint256 _tokenId) internal { // Check if NFT is a wrapped sudoswap pool if (_tokenContract == 0x3767341a7519178f30281fc7D07538EDb55c05a4) { // Get underlying pool ILSSVMPair underlyingPair = ILSSVMPair(address(uint160(_tokenId))); // Get information about pool address nft = underlyingPair.nft(); // Underlying NFT contract ILSSVMPair.PoolType type = underlyingPair.poolType(); // BUY, SELL, or TRADE address curve = underlyingPair.bondingCurve(); // Address of bonding curve uint256 balance = underlyingPair.balance; // ETH balance of pool // Do desired logic ... } else {...} } }","title":"Example"},{"location":"reference/wrapped-pools/#valuing-wrapped-pools","text":"Valuing wrapped pools can be complex due to diverse pricing curves and the risk of manipulation. To mitigate this, we recommend protocols start by only integrating certain categories of sudoswap pools. For example, for a buy- or sell-only pool using a linear or exponential pricing curve, the total value of the pool can be estimated by multiplying its NFT balance by the NFT's floor price (as provided by an NFT valuation oracle of choice) and adding its ETH balance. Additionally, you should check the pool's pricing at the time of valuation is equal to the NFT's floor price or better. For a linear or exponential pricing curve, this means: Buy-only pools: spotPrice \u2264 floor Sell-only pools: spoPrice \u2265 floor","title":"Valuing Wrapped Pools"},{"location":"user-guide/buying-and-selling/","text":"Buying and Selling NFTs You can instantly trade NFTs on sudoswap by buying from and selling into existing NFT liquidity pools. This page contains step-by-step instructions on how to do so. Buying NFTs Go to the Collections page and select a collection. Select the NFTs you want to buy to add them to the cart: Click \"> sudo swap\" to initiate the swap. Confirm the transaction in your wallet. Selling NFTs Go to the Collections page and select a collection. Open the Sell tab at the top of the page: Select the NFTs you want to sell and click \"> sudo swap\". Give sudoswap access to the NFTs by confirming the first transaction in your wallet. Finalize the sale by confirming the second transaction in your wallet.","title":"Buying and Selling NFTs"},{"location":"user-guide/buying-and-selling/#buying-and-selling-nfts","text":"You can instantly trade NFTs on sudoswap by buying from and selling into existing NFT liquidity pools. This page contains step-by-step instructions on how to do so.","title":"Buying and Selling NFTs"},{"location":"user-guide/buying-and-selling/#buying-nfts","text":"Go to the Collections page and select a collection. Select the NFTs you want to buy to add them to the cart: Click \"> sudo swap\" to initiate the swap. Confirm the transaction in your wallet.","title":"Buying NFTs"},{"location":"user-guide/buying-and-selling/#selling-nfts","text":"Go to the Collections page and select a collection. Open the Sell tab at the top of the page: Select the NFTs you want to sell and click \"> sudo swap\". Give sudoswap access to the NFTs by confirming the first transaction in your wallet. Finalize the sale by confirming the second transaction in your wallet.","title":"Selling NFTs"},{"location":"user-guide/creating-a-pool/","text":"Creating a Pool Anyone can provide liquidity on sudoswap. You can choose whether you want to buy or sell NFTs across a range of prices, or do both to earn trading fees. To create a pool, navigate to the Create Pool interface. Follow the steps below depending on the type of pool you want to create. Trade Pool (Buy and Sell) On the Create Pool interface, select an NFT collection in the top-left pane. Optionally, choose an ERC20 token the NFTs should trade against. By default, NFTs trade against ETH: Under the Deposits section, choose how much ETH/ERC20 token to deposit (based on how many NFTs you are willing to buy) and which of your NFTs to deposit to seed the pool: Under the Strategy section, choose a starting Sell price for the pool. The corresponding Buy price is automatically adjusted in the following steps. Adjust the percentage Fee which will be taken on every trade. Select a type of price curve from the dropdown box and adjust the curve parameter as desired. For details about the price curves supported by sudoswap and their adjustable parameter(s), see Bonding Curves . Click \"Create Pool\" and confirm the approval and pool creation transactions in your wallet: Buy-Only Pool On the Create Pool interface, select the Buy pool type in the top right-pane: Follow the same steps you would to create a Trade pool, as documented above. Notice that: Under the Deposits section, you only choose how much ETH/ERC20 token to deposit (based on how many NFTs you are willing to buy) to seed the pool. Under the Strategy section, the starting price you choose is a Buy price. Sell-Only Pool On the Create Pool interface, select the Sell pool type in the top right-pane: Follow the same steps you would to create a Trade pool, as documented above. Notice that: Under the Deposits section, you only choose which of your NFTs to deposit to seed the pool. Under the Strategy section, the starting price you choose is a Sell price. Managing Existing Pools Once you've created a pool, you may wish to update its pricing and deposit or withdraw assets. To edit a pool, click on your address at the top-right of any page, click on My Pools , and select the pool. Updating Pricing Navigate to the My Pools page. Click on the pool you want to change. Click on the \"Edit Pool\" button at the top-right of the page. Enter a new start price, delta, and or swap fee (only for Trade pools) for the pool: Click \"Update\" and confirm the transaction in your wallet. Note: It is not possible to change a pool's type (linear, exponential, etc). Instead, withdraw your assets from the existing pool and create a new one. Depositing and Withdrawing Navigate to the My Pools page. Click on the pool you want to deposit to or withdraw from. Click on the Deposit or Withdraw button in the Tokens or NFTs pane. For tokens, simply enter an amount and click the Deposit or Withdraw button: For NFTs, select the NFTs you wish to deposit or withdraw and click the Deposit or Withdraw button:","title":"Creating a Liquidity Pool"},{"location":"user-guide/creating-a-pool/#creating-a-pool","text":"Anyone can provide liquidity on sudoswap. You can choose whether you want to buy or sell NFTs across a range of prices, or do both to earn trading fees. To create a pool, navigate to the Create Pool interface. Follow the steps below depending on the type of pool you want to create.","title":"Creating a Pool"},{"location":"user-guide/creating-a-pool/#trade-pool-buy-and-sell","text":"On the Create Pool interface, select an NFT collection in the top-left pane. Optionally, choose an ERC20 token the NFTs should trade against. By default, NFTs trade against ETH: Under the Deposits section, choose how much ETH/ERC20 token to deposit (based on how many NFTs you are willing to buy) and which of your NFTs to deposit to seed the pool: Under the Strategy section, choose a starting Sell price for the pool. The corresponding Buy price is automatically adjusted in the following steps. Adjust the percentage Fee which will be taken on every trade. Select a type of price curve from the dropdown box and adjust the curve parameter as desired. For details about the price curves supported by sudoswap and their adjustable parameter(s), see Bonding Curves . Click \"Create Pool\" and confirm the approval and pool creation transactions in your wallet:","title":"Trade Pool (Buy and Sell)"},{"location":"user-guide/creating-a-pool/#buy-only-pool","text":"On the Create Pool interface, select the Buy pool type in the top right-pane: Follow the same steps you would to create a Trade pool, as documented above. Notice that: Under the Deposits section, you only choose how much ETH/ERC20 token to deposit (based on how many NFTs you are willing to buy) to seed the pool. Under the Strategy section, the starting price you choose is a Buy price.","title":"Buy-Only Pool"},{"location":"user-guide/creating-a-pool/#sell-only-pool","text":"On the Create Pool interface, select the Sell pool type in the top right-pane: Follow the same steps you would to create a Trade pool, as documented above. Notice that: Under the Deposits section, you only choose which of your NFTs to deposit to seed the pool. Under the Strategy section, the starting price you choose is a Sell price.","title":"Sell-Only Pool"},{"location":"user-guide/creating-a-pool/#managing-existing-pools","text":"Once you've created a pool, you may wish to update its pricing and deposit or withdraw assets. To edit a pool, click on your address at the top-right of any page, click on My Pools , and select the pool.","title":"Managing Existing Pools"},{"location":"user-guide/creating-a-pool/#updating-pricing","text":"Navigate to the My Pools page. Click on the pool you want to change. Click on the \"Edit Pool\" button at the top-right of the page. Enter a new start price, delta, and or swap fee (only for Trade pools) for the pool: Click \"Update\" and confirm the transaction in your wallet. Note: It is not possible to change a pool's type (linear, exponential, etc). Instead, withdraw your assets from the existing pool and create a new one.","title":"Updating Pricing"},{"location":"user-guide/creating-a-pool/#depositing-and-withdrawing","text":"Navigate to the My Pools page. Click on the pool you want to deposit to or withdraw from. Click on the Deposit or Withdraw button in the Tokens or NFTs pane. For tokens, simply enter an amount and click the Deposit or Withdraw button: For NFTs, select the NFTs you wish to deposit or withdraw and click the Deposit or Withdraw button:","title":"Depositing and Withdrawing"},{"location":"user-guide/creating-an-auction/","text":"Creating an Auction Auctions are a type of sudoswap pool that use the gradual Dutch auction (GDA) or related bonding curves. Anyone can create an auction to buy or sell NFTs on sudoswap. To create an auction, navigate to the Create Auction interface. Then, follow the steps below. On the Create Auction interface, select an NFT collection in the top pane: Choose whether you want to buy or sell NFTs. Optionally, choose an ERC20 token the NFTs should trade against. By default, NFTs trade against ETH. Enter a starting price for the auction and select the auction speed: Enter the total amount you wish to spend or select the NFTs you wish to auction: Click \"Create Auction\" and confirm the approval and pool creation transactions in your wallet. Managing Existing Pools You can deposit and withdraw from auctions as you would for any other sudoswap pool.","title":"Creating an Auction"},{"location":"user-guide/creating-an-auction/#creating-an-auction","text":"Auctions are a type of sudoswap pool that use the gradual Dutch auction (GDA) or related bonding curves. Anyone can create an auction to buy or sell NFTs on sudoswap. To create an auction, navigate to the Create Auction interface. Then, follow the steps below. On the Create Auction interface, select an NFT collection in the top pane: Choose whether you want to buy or sell NFTs. Optionally, choose an ERC20 token the NFTs should trade against. By default, NFTs trade against ETH. Enter a starting price for the auction and select the auction speed: Enter the total amount you wish to spend or select the NFTs you wish to auction: Click \"Create Auction\" and confirm the approval and pool creation transactions in your wallet.","title":"Creating an Auction"},{"location":"user-guide/creating-an-auction/#managing-existing-pools","text":"You can deposit and withdraw from auctions as you would for any other sudoswap pool.","title":"Managing Existing Pools"},{"location":"user-guide/faq/","text":"Frequently Asked Questions This page contains some of the most frequently asked questions among sudoswap users. How are fees calculated? Fees are calculated as a percentage of the net buy or sell price, after bonding curve logic has been applied to the spot price. Prices shown on the sudoswap frontend are the final amounts that a user pays (when buying an NFT) or receives (when selling an NFT) after fees have been accounted for. Example: Spot Price: 0.9 ETH Delta: 0.1 ETH Net Buy Price: 1.0 ETH 5% Creator Royalty: 0.05 ETH 5% Trade Fee: 0.05 ETH 0.5% Protocol Fee: 0.005 ETH Buyer Pays: 1.105 ETH Why did I receive no trade fee / double the trade fee? Users are always charged the exact trade fee when buying or selling an NFT. However, to optimize for gas usage, the trade fee remains in the pool (instead of being sent to the fee recipient) when an NFT is sold into a pool. To compensate for this, double the trade fee is sent to the fee recipient when an NFT is bought from a pool, ensuring fees accrue to the fee recipient in the long term. This amount consists of the fee itself (as paid by the user) and an equal amount deducted from the proceeds of the trade, which would otherwise remain in the pool. Can I withdraw airdropped tokens from my pool? Yes. At any time, you can withdraw any ERC20, ERC721, or ERC1155 tokens from your liqudity pools using the \"Withdraw Other Tokens\" feature on the pool's page. Note that you can only withdraw tokens from pools you have created. What's the difference between selling and listing? When you sell an NFT on sudoswap, it is immediately sold into a bonding curve for the best price possible. This means that you receive the proceeds of the sale right away. When you list an NFT on sudoswap, you can set whatever price you want, but you have to wait until someone buys it from you. Do I get a token representing my liquidity position? No, you will not receive a token representing your liquidity position when creating a new pool. This is because every liquidity pool has a unique smart contract associated with and owned by its creator. All assets pertaining to a pool are held in the pool's smart contract, so there is no need for additional tokens to keep track of deposits. Why is my new liquidity pool not showing up on the sudoswap website? Sudoswap indexes on-chain data at regular intervals. If a new liquidity pool is not showing up, it is usually because sudoswap has not yet had a chance to index the pool's creation. Please check again at a later time. What happens to a trade pool when one side of the pool is depleted? Trade pools remain trade pools even if one side of the pool is depleted. Nevertheless, pools can only fulfill buys and sells if they hold the necessary assets to do so.","title":"Frequently Asked Questions (FAQ)"},{"location":"user-guide/faq/#frequently-asked-questions","text":"This page contains some of the most frequently asked questions among sudoswap users.","title":"Frequently Asked Questions"},{"location":"user-guide/faq/#how-are-fees-calculated","text":"Fees are calculated as a percentage of the net buy or sell price, after bonding curve logic has been applied to the spot price. Prices shown on the sudoswap frontend are the final amounts that a user pays (when buying an NFT) or receives (when selling an NFT) after fees have been accounted for. Example: Spot Price: 0.9 ETH Delta: 0.1 ETH Net Buy Price: 1.0 ETH 5% Creator Royalty: 0.05 ETH 5% Trade Fee: 0.05 ETH 0.5% Protocol Fee: 0.005 ETH Buyer Pays: 1.105 ETH","title":"How are fees calculated?"},{"location":"user-guide/faq/#why-did-i-receive-no-trade-fee-double-the-trade-fee","text":"Users are always charged the exact trade fee when buying or selling an NFT. However, to optimize for gas usage, the trade fee remains in the pool (instead of being sent to the fee recipient) when an NFT is sold into a pool. To compensate for this, double the trade fee is sent to the fee recipient when an NFT is bought from a pool, ensuring fees accrue to the fee recipient in the long term. This amount consists of the fee itself (as paid by the user) and an equal amount deducted from the proceeds of the trade, which would otherwise remain in the pool.","title":"Why did I receive no trade fee / double the trade fee?"},{"location":"user-guide/faq/#can-i-withdraw-airdropped-tokens-from-my-pool","text":"Yes. At any time, you can withdraw any ERC20, ERC721, or ERC1155 tokens from your liqudity pools using the \"Withdraw Other Tokens\" feature on the pool's page. Note that you can only withdraw tokens from pools you have created.","title":"Can I withdraw airdropped tokens from my pool?"},{"location":"user-guide/faq/#whats-the-difference-between-selling-and-listing","text":"When you sell an NFT on sudoswap, it is immediately sold into a bonding curve for the best price possible. This means that you receive the proceeds of the sale right away. When you list an NFT on sudoswap, you can set whatever price you want, but you have to wait until someone buys it from you.","title":"What's the difference between selling and listing?"},{"location":"user-guide/faq/#do-i-get-a-token-representing-my-liquidity-position","text":"No, you will not receive a token representing your liquidity position when creating a new pool. This is because every liquidity pool has a unique smart contract associated with and owned by its creator. All assets pertaining to a pool are held in the pool's smart contract, so there is no need for additional tokens to keep track of deposits.","title":"Do I get a token representing my liquidity position?"},{"location":"user-guide/faq/#why-is-my-new-liquidity-pool-not-showing-up-on-the-sudoswap-website","text":"Sudoswap indexes on-chain data at regular intervals. If a new liquidity pool is not showing up, it is usually because sudoswap has not yet had a chance to index the pool's creation. Please check again at a later time.","title":"Why is my new liquidity pool not showing up on the sudoswap website?"},{"location":"user-guide/faq/#what-happens-to-a-trade-pool-when-one-side-of-the-pool-is-depleted","text":"Trade pools remain trade pools even if one side of the pool is depleted. Nevertheless, pools can only fulfill buys and sells if they hold the necessary assets to do so.","title":"What happens to a trade pool when one side of the pool is depleted?"},{"location":"v2/erc1155/","text":"ERC1155 Support sudoAMM v2 adds support for ERC1155 NFT pairs against both ETH and ERC20 tokens. The design of ERC1155 pairs is similar to that of ERC721 pairs, with the key difference being that ERC1155 pairs must specify a single NFT ID that can be traded by the pair. The NFT ID permitted to trade must be provided when the pair is created, after which it cannot be changed. Factory and Router Support ERC1155 pairs are created with dedicated methods on the LSSVMPairFactory : createPairERC1155ETH and createPairERC1155ERC20 . There are no dedicated methods for ERC1155 pairs on the routers as they are fully compatible with the generic methods.","title":"ERC1155 NFTs"},{"location":"v2/erc1155/#erc1155-support","text":"sudoAMM v2 adds support for ERC1155 NFT pairs against both ETH and ERC20 tokens. The design of ERC1155 pairs is similar to that of ERC721 pairs, with the key difference being that ERC1155 pairs must specify a single NFT ID that can be traded by the pair. The NFT ID permitted to trade must be provided when the pair is created, after which it cannot be changed.","title":"ERC1155 Support"},{"location":"v2/erc1155/#factory-and-router-support","text":"ERC1155 pairs are created with dedicated methods on the LSSVMPairFactory : createPairERC1155ETH and createPairERC1155ERC20 . There are no dedicated methods for ERC1155 pairs on the routers as they are fully compatible with the generic methods.","title":"Factory and Router Support"},{"location":"v2/overview/","text":"Overview sudoAMM v2 introduces four new major features for users and creators: Royalty support for ERC2981-compliant collections, plus fallback royalty solutions LP agreements called Settings whereby creators can opt-in to waive royalties for eligible pools On-chain property filtering powered by Merkle trees, tokenId ranges, or custom smart contract logic ERC1155 support Minor Changes Additionally, v2 brings the following tweaks and optimizations, which may be of relevance to builders: Fee accounting: When creating a TRADE pool, users can now specify a separate address to receive fees by passing an _assetRecipient . If unspecified, fees still accrue to the pair contract. VeryFastRouter : A new router which handles all swap types (i.e. ERC721<>ETH, ERC721<>ERC20, ERC1155<>ETH, ERC1155<>ERC20), as well as partial fills when buying/selling multiple items from the same pool. New swap events: SwapNFTInPair and SwapNFTOutPair distinguish between the direction of swaps, also logging the input/output value and tokenIds (or number of NFTs in case of ERC1155). Gas optimizations: Various minor fixes and gas optimizations have been implemented.","title":"Overview"},{"location":"v2/overview/#overview","text":"sudoAMM v2 introduces four new major features for users and creators: Royalty support for ERC2981-compliant collections, plus fallback royalty solutions LP agreements called Settings whereby creators can opt-in to waive royalties for eligible pools On-chain property filtering powered by Merkle trees, tokenId ranges, or custom smart contract logic ERC1155 support","title":"Overview"},{"location":"v2/overview/#minor-changes","text":"Additionally, v2 brings the following tweaks and optimizations, which may be of relevance to builders: Fee accounting: When creating a TRADE pool, users can now specify a separate address to receive fees by passing an _assetRecipient . If unspecified, fees still accrue to the pair contract. VeryFastRouter : A new router which handles all swap types (i.e. ERC721<>ETH, ERC721<>ERC20, ERC1155<>ETH, ERC1155<>ERC20), as well as partial fills when buying/selling multiple items from the same pool. New swap events: SwapNFTInPair and SwapNFTOutPair distinguish between the direction of swaps, also logging the input/output value and tokenIds (or number of NFTs in case of ERC1155). Gas optimizations: Various minor fixes and gas optimizations have been implemented.","title":"Minor Changes"},{"location":"v2/properties/","text":"Properties sudoAMM v2 introduces the ability to create property-specific liquidity pools. Properties are enforced at the LSSVMPair level on buy methods, meaning that only NFTs with the specified properties can be sold into pools. Property checking logic is contained within dedicated contracts called Property Checkers. Users can develop Property Checkers using the logic of their choosing, but the resulting contracts should conform to the IPropertyChecker.sol interface expected by pair contracts: interface IPropertyChecker { function hasProperties(uint256[] calldata ids, bytes calldata params) external returns(bool); } The interface's single method hasProperties takes an array of tokenIds and optional bytes calldata, returning true or false if the specified tokenIds meet the Property Checker's criteria. The optional bytes calldata can be used to pass additional information to the Property Checker, such as proof-of-inclusion in a Merkle tree. In order to leverage property checking, liquidity providers must specify a Property Checker when creating pools with the Pair Factory. The Property Checker that is specified for a pool at creation cannot be changed or removed. Default Property Checkers sudoAMM v2 provides two default Property Checkers which can be cloned by users with custom parameters. For instructions on doing so, see Cloning Property Checkers . RangePropertyChecker RangePropertyChecker checks whether tokenIds passed to the hasProperties method lie within a lowerBound and upperBound specified when the contract was cloned. For this Property Checker, the optional bytes calldata is not used. MerklePropertyChecker MerklePropertyChecker checks whether tokenIds passed to the hasProperties method are leaves in an arbitrary Merkle tree whose root was specified when the contract was cloned. For this Property Checker, the optional bytes calldata is used by the client to pass a Merkle proof.","title":"Property Checking"},{"location":"v2/properties/#properties","text":"sudoAMM v2 introduces the ability to create property-specific liquidity pools. Properties are enforced at the LSSVMPair level on buy methods, meaning that only NFTs with the specified properties can be sold into pools. Property checking logic is contained within dedicated contracts called Property Checkers. Users can develop Property Checkers using the logic of their choosing, but the resulting contracts should conform to the IPropertyChecker.sol interface expected by pair contracts: interface IPropertyChecker { function hasProperties(uint256[] calldata ids, bytes calldata params) external returns(bool); } The interface's single method hasProperties takes an array of tokenIds and optional bytes calldata, returning true or false if the specified tokenIds meet the Property Checker's criteria. The optional bytes calldata can be used to pass additional information to the Property Checker, such as proof-of-inclusion in a Merkle tree. In order to leverage property checking, liquidity providers must specify a Property Checker when creating pools with the Pair Factory. The Property Checker that is specified for a pool at creation cannot be changed or removed.","title":"Properties"},{"location":"v2/properties/#default-property-checkers","text":"sudoAMM v2 provides two default Property Checkers which can be cloned by users with custom parameters. For instructions on doing so, see Cloning Property Checkers .","title":"Default Property Checkers"},{"location":"v2/properties/#rangepropertychecker","text":"RangePropertyChecker checks whether tokenIds passed to the hasProperties method lie within a lowerBound and upperBound specified when the contract was cloned. For this Property Checker, the optional bytes calldata is not used.","title":"RangePropertyChecker"},{"location":"v2/properties/#merklepropertychecker","text":"MerklePropertyChecker checks whether tokenIds passed to the hasProperties method are leaves in an arbitrary Merkle tree whose root was specified when the contract was cloned. For this Property Checker, the optional bytes calldata is used by the client to pass a Merkle proof.","title":"MerklePropertyChecker"},{"location":"v2/royalties/","text":"Royalties With sudoAMM v2, royalties are enforced on liquidity pools at the contract level. Royalties are automatically enabled for collections implementing the ERC2981 royalty standard as well as collections created with supported marketplaces such as Manifold/Foundation, Rarible, SuperRare, or Zora (limited functionality). Additionally, creators can use the shared Royalty Registry deployed at royaltyregistry.eth to manually override royalties, e.g. for older collections which do not implement ERC2981. Royalty Engine The RoyaltyEngine contract determines the provisional value of royalties due for a swap of given value and the address that should receive them. It is a fork of the Royalty Engine created by Manifold as part of the Royalty Registry initiative. If a collection implements ERC2981, the RoyaltyEngine retrieves royalty information from the collection contract itself. Failing this, the RoyaltyEngine searches for royalty information against popular marketplace specifications: Manifold Rarible V1 and V2 Foundation SuperRare Zora ArtBlocks KnownOriginV2 The RoyaltyEngine also searches for entries in the shared Royalty Registry at royaltyregistry.eth, where creators can manually override royalties. Royalty information returned from the engine is used in the _calculateRoyalties function on pair contracts, which is called internally by all swap methods, unless: The royalty exceeds the sale price, in which case no royalty is applied A Setting is in place for the pool... Settings When a Setting is in place for a given pair, the _calculateRoyalties function will overwrite the royalty value returned by the RoyaltyEngine using the getFeeSplitBps view on the Setting contract.","title":"Royalties"},{"location":"v2/royalties/#royalties","text":"With sudoAMM v2, royalties are enforced on liquidity pools at the contract level. Royalties are automatically enabled for collections implementing the ERC2981 royalty standard as well as collections created with supported marketplaces such as Manifold/Foundation, Rarible, SuperRare, or Zora (limited functionality). Additionally, creators can use the shared Royalty Registry deployed at royaltyregistry.eth to manually override royalties, e.g. for older collections which do not implement ERC2981.","title":"Royalties"},{"location":"v2/royalties/#royalty-engine","text":"The RoyaltyEngine contract determines the provisional value of royalties due for a swap of given value and the address that should receive them. It is a fork of the Royalty Engine created by Manifold as part of the Royalty Registry initiative. If a collection implements ERC2981, the RoyaltyEngine retrieves royalty information from the collection contract itself. Failing this, the RoyaltyEngine searches for royalty information against popular marketplace specifications: Manifold Rarible V1 and V2 Foundation SuperRare Zora ArtBlocks KnownOriginV2 The RoyaltyEngine also searches for entries in the shared Royalty Registry at royaltyregistry.eth, where creators can manually override royalties. Royalty information returned from the engine is used in the _calculateRoyalties function on pair contracts, which is called internally by all swap methods, unless: The royalty exceeds the sale price, in which case no royalty is applied A Setting is in place for the pool...","title":"Royalty Engine"},{"location":"v2/royalties/#settings","text":"When a Setting is in place for a given pair, the _calculateRoyalties function will overwrite the royalty value returned by the RoyaltyEngine using the getFeeSplitBps view on the Setting contract.","title":"Settings"},{"location":"v2/settings/","text":"Settings New in sudoAMM v2, Settings are opt-in contracts that allow creators to waive (partially or entirely) royalties for liquidity pools that meet their chosen criteria, such as a 90-day lockup period or 50:50 trading fee split. Creators can develop Settings using the logic of their choosing, but the resulting contract should conform to the ISettings.sol interface: interface ISettings { struct PairInfo { address prevOwner; uint96 unlockTime; address prevFeeRecipient; } function getFeeSplitBps() external pure returns (uint64); function getRoyaltyInfo(address pairAddress) external view returns (bool, uint96); function settingsFeeRecipient() external returns (address payable); function getPrevFeeRecipientForPair(address pairAddress) external returns (address); } Once a Setting has been deployed, the creator of the relevant NFT collection should call toggleSettingsForCollection on the Pair Factory to ratify the Setting, thus waiving royalties for pools enrolled in that Settings. To enroll in a Setting, liquidity providers transfer ownership of their pool to the Setting contract using the transferOwnership method on the pool contract. Creators should design Settings such that only pools which meet the desired criteria can be transferred to the Setting contract. Standard Settings A Standard Setting is a standardized type of Setting with three criteria: ethCost , an upfront fee to the liquidity provider in gwei secDuration , a lockup period in seconds feeSplitBps , a trading fee split in basis points Any liquidity provider who accepts these criteria can participate in the Setting. Following the lockup period, the liquidity provider can call reclaimPair on the Setting contract to withdraw their pool from the Setting. Creators can deploy Standard Settings without writing any code by using the createSettings method on the StandardSettingsFactory . In addition to the criteria above, this method takes two parameters: settingsFeeRecipient , the address which will receive the creator's trading fee split royaltyBps , the waived royalty rate in basis points Fee Splitter When ownership of a liquidity pool is transferred to a Standard Settings contract, a fee splitter ( Splitter.sol ) is deployed to handle the distribution of trading fees between the liqudity provider and creator. Any address or contract can call the withdrawal methods on the Splitter, such as withdrawETH , to atomically withdraw all accrued fees and split them between the liqudity provider and creator per the feeSplitBps . Additionally, Setting owners can call bulkWithdrawFees on a Setting to trigger fee withdrawal from all Fee Splitters deployed under that Setting.","title":"Settings"},{"location":"v2/settings/#settings","text":"New in sudoAMM v2, Settings are opt-in contracts that allow creators to waive (partially or entirely) royalties for liquidity pools that meet their chosen criteria, such as a 90-day lockup period or 50:50 trading fee split. Creators can develop Settings using the logic of their choosing, but the resulting contract should conform to the ISettings.sol interface: interface ISettings { struct PairInfo { address prevOwner; uint96 unlockTime; address prevFeeRecipient; } function getFeeSplitBps() external pure returns (uint64); function getRoyaltyInfo(address pairAddress) external view returns (bool, uint96); function settingsFeeRecipient() external returns (address payable); function getPrevFeeRecipientForPair(address pairAddress) external returns (address); } Once a Setting has been deployed, the creator of the relevant NFT collection should call toggleSettingsForCollection on the Pair Factory to ratify the Setting, thus waiving royalties for pools enrolled in that Settings. To enroll in a Setting, liquidity providers transfer ownership of their pool to the Setting contract using the transferOwnership method on the pool contract. Creators should design Settings such that only pools which meet the desired criteria can be transferred to the Setting contract.","title":"Settings"},{"location":"v2/settings/#standard-settings","text":"A Standard Setting is a standardized type of Setting with three criteria: ethCost , an upfront fee to the liquidity provider in gwei secDuration , a lockup period in seconds feeSplitBps , a trading fee split in basis points Any liquidity provider who accepts these criteria can participate in the Setting. Following the lockup period, the liquidity provider can call reclaimPair on the Setting contract to withdraw their pool from the Setting. Creators can deploy Standard Settings without writing any code by using the createSettings method on the StandardSettingsFactory . In addition to the criteria above, this method takes two parameters: settingsFeeRecipient , the address which will receive the creator's trading fee split royaltyBps , the waived royalty rate in basis points","title":"Standard Settings"},{"location":"v2/settings/#fee-splitter","text":"When ownership of a liquidity pool is transferred to a Standard Settings contract, a fee splitter ( Splitter.sol ) is deployed to handle the distribution of trading fees between the liqudity provider and creator. Any address or contract can call the withdrawal methods on the Splitter, such as withdrawETH , to atomically withdraw all accrued fees and split them between the liqudity provider and creator per the feeSplitBps . Additionally, Setting owners can call bulkWithdrawFees on a Setting to trigger fee withdrawal from all Fee Splitters deployed under that Setting.","title":"Fee Splitter"}]}